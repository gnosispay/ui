// This file is auto-generated by @hey-api/openapi-ts

export type AuthRequest = {
    auth?: Authorization;
};

export type Authorization = {
    userId: string;
    signerAddress?: string | null;
    chainId?: string | null;
    iat: number;
    exp: number;
    hasSignedUp: boolean;
};

export type _Error = {
    /**
     * Error message
     */
    error?: string;
};

export type Card = {
    id: string;
    cardToken?: string;
    lastFourDigits: string;
    activatedAt?: string | null;
    virtual?: boolean;
};

export type CardOrder = {
    id: string;
    transactionHash?: string;
    createdAt: string;
    /**
     * Current order status in the state machine. See the state transition diagram in the documentation for valid transitions.
     */
    status: 'PENDINGTRANSACTION' | 'TRANSACTIONCOMPLETE' | 'CONFIRMATIONREQUIRED' | 'READY' | 'CARDCREATED' | 'FAILEDTRANSACTION' | 'CANCELLED';
    personalizationSource: 'KYC' | 'ENS';
    embossedName?: string;
    address1?: string;
    address2?: string;
    city?: string;
    country?: string;
    postalCode?: string;
    state?: string;
    couponCode?: string;
    totalAmountEUR?: number;
    totalDiscountEUR: number;
    virtual?: boolean;
};

export type CardAlreadyActiveError = {
    error?: 'Card has been already activated';
};

export type CardBlockedError = {
    error?: 'The card is blocked';
};

export type AssociatedSafeAccountNotFoundError = {
    error?: "Couldn't find an associated Safe account";
};

export type DelayTransaction = {
    /**
     * Unique identifier for the delayed transaction.
     */
    id?: string;
    /**
     * The Safe contract address associated with the transaction.
     */
    safeAddress?: string;
    /**
     * Data payload of the transaction.
     */
    transactionData?: string;
    /**
     * Identifier of the task that enqueued this transaction.
     */
    enqueueTaskId?: string;
    /**
     * Identifier of the task responsible for dispatching this transaction.
     */
    dispatchTaskId?: string | null;
    /**
     * Timestamp indicating when the transaction is ready for processing.
     */
    readyAt?: string | null;
    /**
     * Type of operation being performed.
     */
    operationType?: 'CALL' | 'DELEGATECALL';
    /**
     * Identifier of the user associated with the transaction.
     */
    userId?: string;
    /**
     * Current status of the transaction.
     */
    status?: 'QUEUING' | 'WAITING' | 'EXECUTING' | 'EXECUTED' | 'FAILED';
    /**
     * Timestamp of when the transaction was created.
     */
    createdAt?: string;
};

export type AccountAllowance = {
    /**
     * The current balance of the account's allowance.
     */
    balance?: string;
    /**
     * The refill amount for the account's allowance.
     */
    refill?: string;
    /**
     * The period for allowance refills.
     */
    period?: string;
    /**
     * The timestamp for the next refill, if available.
     */
    nextRefill?: string | null;
};

/**
 * Enum representing the integrity status of the account
 */
export type AccountIntegrityStatus = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;

export type SafeConfig = {
    /**
     * Indicates whether the safe has no approvals.
     */
    hasNoApprovals?: boolean;
    /**
     * Indicates whether the safe is deployed.
     */
    isDeployed?: boolean;
    /**
     * The address of the safe, if available.
     */
    address?: string | null;
    /**
     * The token symbol associated with the safe.
     */
    tokenSymbol?: string | null;
    /**
     * The fiat symbol derived from the token symbol.
     */
    fiatSymbol?: string | null;
    accountStatus?: AccountIntegrityStatus;
    accountAllowance?: AccountAllowance;
};

export type KycQuestion = {
    /**
     * The text of the question.
     */
    question?: string;
    /**
     * The possible answers to the question.
     */
    answers?: Array<string>;
};

export type KycAnswer = {
    /**
     * The text of the question being answered.
     */
    question?: string;
    /**
     * The user's answer to the question.
     */
    answer?: string;
};

export type Currency = {
    symbol?: string;
    code?: string;
    decimals?: number;
    name?: string;
};

export type Country = {
    name?: string;
    numeric?: string;
    alpha2?: string;
    alpha3?: string;
};

export type Transaction = {
    status?: 'Unsubmitted' | 'Unconfirmed' | 'ExecReverted' | 'ExecSuccess';
    to?: string;
    /**
     * A BigInt value represented as a string
     */
    value?: string;
    data?: string;
    hash?: string | null;
};

export type BasePaymentish = {
    createdAt?: string;
    /**
     * Date of the latest clearing record of the transaction
     */
    clearedAt?: string | null;
    country?: Country;
    /**
     * Whether the transaction is pending. Pending means awaiting settlement (if it is not a reversal or refund)
     */
    isPending?: boolean;
    mcc?: string;
    merchant?: {
        name?: string;
        city?: string;
        country?: Country;
    };
    /**
     * A BigInt value represented as a string
     */
    billingAmount?: string;
    billingCurrency?: Currency;
    /**
     * A BigInt value represented as a string
     */
    transactionAmount?: string;
    transactionCurrency?: Currency;
    /**
     * First 2 digits of the DE3 field (ISO 8583), representing the transaction type code.
     * Common values include (not limited to):
     * - "00": Purchase (POS)
     * - "01": Withdrawal (ATM)
     * - "10": Account Funding
     * - "20": Return of Goods
     * - "28": Prepaid Load
     * - "30": Balance Inquiry
     * - "70": PIN Change
     * - "72": PIN Unblock
     *
     */
    transactionType?: string;
    transactions?: Array<Transaction>;
};

export type Payment = BasePaymentish & {
    kind?: 'Payment';
    status?: 'Approved' | 'IncorrectPin' | 'InsufficientFunds' | 'InvalidAmount' | 'PinEntryTriesExceeded' | 'IncorrectSecurityCode' | 'Reversal' | 'PartialReversal' | 'Other';
};

export type Refund = BasePaymentish & {
    kind?: 'Refund';
    /**
     * A BigInt value represented as a string
     */
    refundAmount?: string;
    refundCurrency?: Currency;
};

export type Reversal = BasePaymentish & {
    kind?: 'Reversal';
    /**
     * A BigInt value represented as a string
     */
    reversalAmount?: string;
    reversalCurrency?: Currency;
};

export type Event = Payment | Refund | Reversal;

export type EoaAccount = {
    id?: string;
    address?: string;
    userId?: string;
    createdAt?: string;
};

export type IbanOrder = {
    /**
     * Unique identifier for the order.
     */
    id: string;
    /**
     * Type of order.
     */
    kind: 'redeem' | 'issue';
    /**
     * Currency of the order.
     */
    currency: 'eur' | 'usd' | 'gbp' | 'isk';
    /**
     * Amount of the transaction in string format.
     */
    amount: string;
    /**
     * Ethereum address associated with the order.
     */
    address: string;
    /**
     * Counterparty details.
     */
    counterpart: {
        details: {
            name?: string;
        };
        identifier: {
            standard: 'iban';
            iban: string;
        } | {
            standard: 'chain';
            address: string;
            chain: string;
        };
    };
    /**
     * Optional memo for the order.
     */
    memo?: string | null;
    /**
     * State of the order.
     */
    state: 'placed' | 'pending' | 'processed' | 'rejected';
    meta: {
        /**
         * Timestamp when the order was placed.
         */
        placedAt: string;
    };
};

export type KycStatus = 'notStarted' | 'documentsRequested' | 'pending' | 'processing' | 'approved' | 'resubmissionRequested' | 'rejected' | 'requiresAction';

export type SafeAccount = {
    id: string;
    address: string;
    salt?: string | null;
    chainId?: string;
    userId: string;
    tokenSymbol?: string;
    createdAt: string;
};

export type BankingDetails = {
    id?: string;
    address?: string;
    moneriumIban?: string;
    moneriumBic?: string;
    moneriumIbanStatus?: string;
    userId?: string;
    createdAt?: string;
    updatedAt?: string;
};

export type User = {
    id?: string;
    email?: string | null;
    firstName?: string | null;
    lastName?: string | null;
    country?: string | null;
    nationalityCountry?: string | null;
    signInWallets?: Array<EoaAccount>;
    safeWallets?: Array<SafeAccount>;
    kycStatus?: KycStatus;
    availableFeatures?: {
        moneriumIban?: boolean;
    };
    cards?: Array<Card>;
    bankingDetails?: BankingDetails;
    isSourceOfFundsAnswered?: boolean;
    isPhoneValidated?: boolean;
};

export type GetApiV1AccountBalancesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/account-balances';
};

export type GetApiV1AccountBalancesErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type GetApiV1AccountBalancesError = GetApiV1AccountBalancesErrors[keyof GetApiV1AccountBalancesErrors];

export type GetApiV1AccountBalancesResponses = {
    /**
     * The account balance details.
     */
    200: {
        /**
         * The total balance for this account (spendable and pending).
         */
        total: string;
        /**
         * The amount that can be spent from this account.
         */
        spendable: string;
        /**
         * The amount that is being reviewed for spending.
         */
        pending: string;
    };
};

export type GetApiV1AccountBalancesResponse = GetApiV1AccountBalancesResponses[keyof GetApiV1AccountBalancesResponses];

export type PostApiV1AccountData = {
    body: {
        /**
         * The ID of chain (currently only supports Gnosis Chain)
         */
        chainId: '100';
    };
    path?: never;
    query?: never;
    url: '/api/v1/account';
};

export type PostApiV1AccountErrors = {
    /**
     * Bad request (missing parameters or signer address)
     */
    400: {
        /**
         * Error message
         */
        error?: string;
    };
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type PostApiV1AccountError = PostApiV1AccountErrors[keyof PostApiV1AccountErrors];

export type PostApiV1AccountResponses = {
    /**
     * Successfully created or checked Safe account
     */
    200: {
        /**
         * The Safe account ID
         */
        id?: string;
        /**
         * The Safe account address
         */
        address?: string;
        /**
         * ID of the user owning this Safe
         */
        userId?: string;
        /**
         * ID of the blockchain
         */
        chainId?: string;
        /**
         * Salt used for Safe address generation
         */
        salt?: string;
        /**
         * Timestamp of when the Safe was created
         */
        createdAt?: string;
        /**
         * Whether the Safe is deployed on-chain
         */
        deployed?: boolean;
        /**
         * Transaction hash of the deployment transaction (if completed)
         */
        transactionHash?: string;
    };
};

export type PostApiV1AccountResponse = PostApiV1AccountResponses[keyof PostApiV1AccountResponses];

export type GetApiV1AccountSignaturePayloadData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/account/signature-payload';
};

export type GetApiV1AccountSignaturePayloadErrors = {
    /**
     * Bad request (missing account, token, or signer)
     */
    400: {
        /**
         * Error message explaining why the request failed
         */
        error?: string;
    };
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type GetApiV1AccountSignaturePayloadError = GetApiV1AccountSignaturePayloadErrors[keyof GetApiV1AccountSignaturePayloadErrors];

export type GetApiV1AccountSignaturePayloadResponses = {
    /**
     * Signature data for EIP-712 typed data signing
     */
    200: {
        /**
         * Domain data for EIP-712 signature
         */
        domain?: {
            [key: string]: unknown;
        };
        /**
         * Primary type for EIP-712 signature
         */
        primaryType?: string;
        /**
         * Type definitions for EIP-712 signature
         */
        types?: {
            [key: string]: unknown;
        };
        /**
         * Message data for EIP-712 signature
         */
        message?: {
            [key: string]: unknown;
        };
    };
};

export type GetApiV1AccountSignaturePayloadResponse = GetApiV1AccountSignaturePayloadResponses[keyof GetApiV1AccountSignaturePayloadResponses];

export type PatchApiV1AccountDeploySafeModulesData = {
    body: {
        /**
         * The EIP-712 signature for the account setup transaction
         */
        signature: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/account/deploy-safe-modules';
};

export type PatchApiV1AccountDeploySafeModulesErrors = {
    /**
     * Bad request (missing parameters, account, or signer)
     */
    400: {
        /**
         * Error message explaining why the request failed
         */
        error?: string;
    };
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type PatchApiV1AccountDeploySafeModulesError = PatchApiV1AccountDeploySafeModulesErrors[keyof PatchApiV1AccountDeploySafeModulesErrors];

export type PatchApiV1AccountDeploySafeModulesResponses = {
    /**
     * Successfully executed setup transaction
     */
    200: {
        /**
         * The transaction hash of the executed transaction
         */
        transactionHash?: string;
        /**
         * Whether the account setup is deployed
         */
        deployed?: boolean;
    };
};

export type PatchApiV1AccountDeploySafeModulesResponse = PatchApiV1AccountDeploySafeModulesResponses[keyof PatchApiV1AccountDeploySafeModulesResponses];

export type GetApiV1AuthNonceData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/auth/nonce';
};

export type GetApiV1AuthNonceErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type GetApiV1AuthNonceError = GetApiV1AuthNonceErrors[keyof GetApiV1AuthNonceErrors];

export type GetApiV1AuthNonceResponses = {
    /**
     * Nonce generated successfully
     */
    200: string;
};

export type GetApiV1AuthNonceResponse = GetApiV1AuthNonceResponses[keyof GetApiV1AuthNonceResponses];

export type PostApiV1AuthChallengeData = {
    body: {
        /**
         * SIWE message containing the nonce
         */
        message: string;
        /**
         * EOA signature or EIP-1271 contract signature
         */
        signature: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/auth/challenge';
};

export type PostApiV1AuthChallengeErrors = {
    /**
     * Invalid signature
     */
    401: unknown;
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type PostApiV1AuthChallengeError = PostApiV1AuthChallengeErrors[keyof PostApiV1AuthChallengeErrors];

export type PostApiV1AuthChallengeResponses = {
    /**
     * Signature verified successfully
     */
    200: {
        /**
         * JWT token for API authentication
         */
        token?: string;
    };
};

export type PostApiV1AuthChallengeResponse = PostApiV1AuthChallengeResponses[keyof PostApiV1AuthChallengeResponses];

export type PostApiV1AuthSignupData = {
    body: {
        /**
         * Email address for the new user
         */
        authEmail: string;
        /**
         * One-time password for email verification (optional during transition period)
         */
        otp?: string;
        /**
         * Referral coupon code for the new user
         */
        referralCouponCode?: string;
        /**
         * Marketing campaign identifier
         */
        marketingCampaign?: string;
        /**
         * Optional ID of the partner that referred the user
         */
        partnerId?: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/auth/signup';
};

export type PostApiV1AuthSignupErrors = {
    /**
     * Invalid partner ID
     */
    400: {
        error?: string;
    };
    /**
     * Invalid or expired OTP
     */
    401: {
        error?: string;
    };
    /**
     * Email address or wallet address already registered
     */
    409: {
        error?: string;
    };
    /**
     * Invalid request body
     */
    422: {
        error?: string;
    };
    /**
     * Internal server error
     */
    500: {
        /**
         * Details about the server error
         */
        error?: string;
    };
};

export type PostApiV1AuthSignupError = PostApiV1AuthSignupErrors[keyof PostApiV1AuthSignupErrors];

export type PostApiV1AuthSignupResponses = {
    /**
     * User was created successfully
     */
    201: {
        /**
         * Unique identifier of the created user
         */
        id: string;
        /**
         * JWT token for authentication
         */
        token: string;
        /**
         * Indicates if the user has completed signup
         */
        hasSignedUp: boolean;
    };
};

export type PostApiV1AuthSignupResponse = PostApiV1AuthSignupResponses[keyof PostApiV1AuthSignupResponses];

export type PostApiV1AuthSignupOtpData = {
    body: {
        /**
         * Email address to send the OTP to
         */
        email: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/auth/signup/otp';
};

export type PostApiV1AuthSignupOtpErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Invalid request body
     */
    422: {
        error?: string;
    };
    /**
     * Failed to send OTP
     */
    500: {
        error?: string;
    };
};

export type PostApiV1AuthSignupOtpError = PostApiV1AuthSignupOtpErrors[keyof PostApiV1AuthSignupOtpErrors];

export type PostApiV1AuthSignupOtpResponses = {
    /**
     * OTP was sent successfully
     */
    200: {
        /**
         * Indicates if the OTP was sent successfully
         */
        ok: boolean;
    };
};

export type PostApiV1AuthSignupOtpResponse = PostApiV1AuthSignupOtpResponses[keyof PostApiV1AuthSignupOtpResponses];

export type PostApiV1CardsByCardIdActivateData = {
    body?: never;
    path: {
        cardId: string;
    };
    query?: never;
    url: '/api/v1/cards/{cardId}/activate';
};

export type PostApiV1CardsByCardIdActivateErrors = {
    /**
     * Missing signer address
     */
    400: unknown;
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * No card found
     */
    404: unknown;
    /**
     * Request could not be processed
     */
    422: CardAlreadyActiveError | CardBlockedError | AssociatedSafeAccountNotFoundError;
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type PostApiV1CardsByCardIdActivateError = PostApiV1CardsByCardIdActivateErrors[keyof PostApiV1CardsByCardIdActivateErrors];

export type PostApiV1CardsByCardIdActivateResponses = {
    /**
     * The card was activated successfully
     */
    200: {
        status?: 'Card activated successfully';
    };
};

export type PostApiV1CardsByCardIdActivateResponse = PostApiV1CardsByCardIdActivateResponses[keyof PostApiV1CardsByCardIdActivateResponses];

export type PostApiV1CardsByCardIdFreezeData = {
    body?: never;
    path: {
        cardId: string;
    };
    query?: never;
    url: '/api/v1/cards/{cardId}/freeze';
};

export type PostApiV1CardsByCardIdFreezeErrors = {
    /**
     * Invalid card status transition attempted
     */
    400: unknown;
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * No card found
     */
    404: unknown;
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type PostApiV1CardsByCardIdFreezeError = PostApiV1CardsByCardIdFreezeErrors[keyof PostApiV1CardsByCardIdFreezeErrors];

export type PostApiV1CardsByCardIdFreezeResponses = {
    /**
     * Card frozen successfully
     */
    200: {
        status: 'Card frozen successfully';
    };
};

export type PostApiV1CardsByCardIdFreezeResponse = PostApiV1CardsByCardIdFreezeResponses[keyof PostApiV1CardsByCardIdFreezeResponses];

export type PostApiV1CardsByCardIdLostData = {
    body?: never;
    path: {
        cardId: string;
    };
    query?: never;
    url: '/api/v1/cards/{cardId}/lost';
};

export type PostApiV1CardsByCardIdLostErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * No card found
     */
    404: unknown;
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type PostApiV1CardsByCardIdLostError = PostApiV1CardsByCardIdLostErrors[keyof PostApiV1CardsByCardIdLostErrors];

export type PostApiV1CardsByCardIdLostResponses = {
    /**
     * Card marked as lost successfully
     */
    200: {
        status: 'Card marked as lost successfully';
    };
};

export type PostApiV1CardsByCardIdLostResponse = PostApiV1CardsByCardIdLostResponses[keyof PostApiV1CardsByCardIdLostResponses];

export type GetApiV1CardsByCardIdStatusData = {
    body?: never;
    path: {
        cardId: string;
    };
    query?: never;
    url: '/api/v1/cards/{cardId}/status';
};

export type GetApiV1CardsByCardIdStatusErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * No card found
     */
    404: unknown;
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type GetApiV1CardsByCardIdStatusError = GetApiV1CardsByCardIdStatusErrors[keyof GetApiV1CardsByCardIdStatusErrors];

export type GetApiV1CardsByCardIdStatusResponses = {
    /**
     * Card Status was retrieved successfully
     */
    200: {
        activatedAt?: string;
        statusCode: number;
        isFrozen: boolean;
        isStolen: boolean;
        isLost: boolean;
        isBlocked: boolean;
        isVoid: boolean;
    };
};

export type GetApiV1CardsByCardIdStatusResponse = GetApiV1CardsByCardIdStatusResponses[keyof GetApiV1CardsByCardIdStatusResponses];

export type PostApiV1CardsByCardIdStolenData = {
    body?: never;
    path: {
        cardId: string;
    };
    query?: never;
    url: '/api/v1/cards/{cardId}/stolen';
};

export type PostApiV1CardsByCardIdStolenErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * No card found
     */
    404: unknown;
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type PostApiV1CardsByCardIdStolenError = PostApiV1CardsByCardIdStolenErrors[keyof PostApiV1CardsByCardIdStolenErrors];

export type PostApiV1CardsByCardIdStolenResponses = {
    /**
     * Card marked as stolen successfully
     */
    200: {
        status: 'Card marked as stolen successfully';
    };
};

export type PostApiV1CardsByCardIdStolenResponse = PostApiV1CardsByCardIdStolenResponses[keyof PostApiV1CardsByCardIdStolenResponses];

export type PostApiV1CardsByCardIdUnfreezeData = {
    body?: never;
    path: {
        cardId: string;
    };
    query?: never;
    url: '/api/v1/cards/{cardId}/unfreeze';
};

export type PostApiV1CardsByCardIdUnfreezeErrors = {
    /**
     * Invalid card status transition attempted
     */
    400: unknown;
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * No card found
     */
    404: unknown;
    /**
     * Card is not activated
     */
    422: unknown;
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type PostApiV1CardsByCardIdUnfreezeError = PostApiV1CardsByCardIdUnfreezeErrors[keyof PostApiV1CardsByCardIdUnfreezeErrors];

export type PostApiV1CardsByCardIdUnfreezeResponses = {
    /**
     * Card unfrozen successfully
     */
    200: {
        status: 'Card unfrozen successfully';
    };
};

export type PostApiV1CardsByCardIdUnfreezeResponse = PostApiV1CardsByCardIdUnfreezeResponses[keyof PostApiV1CardsByCardIdUnfreezeResponses];

export type PostApiV1CardsByCardIdVoidData = {
    body?: never;
    path: {
        cardId: string;
    };
    query?: never;
    url: '/api/v1/cards/{cardId}/void';
};

export type PostApiV1CardsByCardIdVoidErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * No card found
     */
    404: unknown;
    /**
     * Only virtual cards can be voided
     */
    422: {
        error: 'Only virtual cards can be voided';
    };
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type PostApiV1CardsByCardIdVoidError = PostApiV1CardsByCardIdVoidErrors[keyof PostApiV1CardsByCardIdVoidErrors];

export type PostApiV1CardsByCardIdVoidResponses = {
    /**
     * Card marked as void successfully
     */
    200: {
        status: 'Card marked as void successfully';
    };
};

export type PostApiV1CardsByCardIdVoidResponse = PostApiV1CardsByCardIdVoidResponses[keyof PostApiV1CardsByCardIdVoidResponses];

export type GetApiV1CardsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Exclude voided cards from the response
         */
        exclude_voided?: boolean;
    };
    url: '/api/v1/cards';
};

export type GetApiV1CardsErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * No cards found
     */
    404: unknown;
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type GetApiV1CardsError = GetApiV1CardsErrors[keyof GetApiV1CardsErrors];

export type GetApiV1CardsResponses = {
    /**
     * The list of cards for a user
     */
    200: Array<{
        id: string;
        cardToken: string;
        lastFourDigits: string;
        activatedAt: string | null;
        virtual: boolean;
        /**
         * Card status code from payment processor. Possible values:
         * - 1000: Active
         * - 1001: Refer to Issuer
         * - 1004: Capture
         * - 1005: Declined
         * - 1006: Pin Blocked
         * - 1007: Declined
         * - 1008: Honour with ID
         * - 1009: Void
         * - 1041: Lost
         * - 1043: Stolen
         * - 1054: Expired
         * - 1154: Expired
         * - 1062: Restricted
         * - 1199: Void
         *
         */
        statusCode: 1000 | 1001 | 1004 | 1005 | 1006 | 1007 | 1008 | 1009 | 1041 | 1043 | 1054 | 1154 | 1062 | 1199;
        /**
         * Human-readable card status name corresponding to statusCode:
         * - "Active": Card is active and can be used
         * - "Refer to Issuer": Transaction requires issuer approval
         * - "Capture": Card should be captured/retained
         * - "Declined": All transactions are declined
         * - "Pin Blocked": Card PIN is blocked due to incorrect attempts
         * - "Honour with ID": Transaction requires ID verification
         * - "Void": Card is voided/cancelled
         * - "Lost": Card is reported as lost
         * - "Stolen": Card is reported as stolen
         * - "Expired": Card has expired
         * - "Restricted": Card has restrictions applied
         * - "Unknown": Status code not recognized
         *
         */
        statusName: string;
    }>;
};

export type GetApiV1CardsResponse = GetApiV1CardsResponses[keyof GetApiV1CardsResponses];

export type GetApiV1DelayRelayData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/delay-relay';
};

export type GetApiV1DelayRelayErrors = {
    /**
     * Unauthorized, missing or invalid token.
     */
    401: unknown;
    /**
     * Internal server error.
     */
    500: unknown;
};

export type GetApiV1DelayRelayResponses = {
    /**
     * A list of delayed transactions for the current user.
     */
    200: Array<DelayTransaction>;
};

export type GetApiV1DelayRelayResponse = GetApiV1DelayRelayResponses[keyof GetApiV1DelayRelayResponses];

export type PostApiV1DelayRelayData = {
    body: {
        /**
         * Chain ID for the transaction (only 100 supported)
         */
        chainId: 100;
        /**
         * Target address for the transaction
         */
        target: string;
        /**
         * Signed transaction data
         */
        signedData: string;
        /**
         * The Safe contract address
         */
        safeAddress: string;
        /**
         * Type of operation (optional)
         */
        operationType?: 'CALL' | 'DELEGATECALL';
        transactionData: {
            /**
             * Recipient address
             */
            to: string;
            /**
             * Transaction value (optional)
             */
            value?: string;
            /**
             * Transaction data
             */
            data: string;
        };
    };
    path?: never;
    query?: never;
    url: '/api/v1/delay-relay';
};

export type PostApiV1DelayRelayErrors = {
    /**
     * Invalid request body
     */
    400: unknown;
    /**
     * Unauthorized, missing or invalid token
     */
    401: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type PostApiV1DelayRelayResponses = {
    /**
     * Successfully created delayed transaction
     */
    200: DelayTransaction;
};

export type PostApiV1DelayRelayResponse = PostApiV1DelayRelayResponses[keyof PostApiV1DelayRelayResponses];

export type GetApiV1OrderData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/order/';
};

export type GetApiV1OrderErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Internal server error.
     */
    500: {
        /**
         * Details about the server error.
         */
        message?: string;
    };
};

export type GetApiV1OrderError = GetApiV1OrderErrors[keyof GetApiV1OrderErrors];

export type GetApiV1OrderResponses = {
    /**
     * The card orders for the user
     */
    200: Array<{
        /**
         * The unique identifier of the card order.
         */
        id: string;
        /**
         * The on-chain transaction hash associated with the order.
         */
        transactionHash?: string | null;
        /**
         * The name embossed on the card.
         */
        embossedName?: string | null;
        /**
         * The first line of the shipping address.
         */
        address1?: string | null;
        /**
         * The second line of the shipping address.
         */
        address2?: string | null;
        /**
         * The city of the shipping address.
         */
        city?: string | null;
        /**
         * The postal code of the shipping address.
         */
        postalCode?: string | null;
        /**
         * The state of the shipping address.
         */
        state?: string | null;
        /**
         * The country of the shipping address.
         */
        country?: string | null;
        /**
         * The user id for this card order.
         */
        userId: string;
        /**
         * Current order status
         */
        status: 'PENDINGTRANSACTION' | 'TRANSACTIONCOMPLETE' | 'CONFIRMATIONREQUIRED' | 'READY' | 'CARDCREATED' | 'FAILEDTRANSACTION' | 'CANCELLED';
        personalizationSource: 'KYC' | 'ENS';
        /**
         * The coupon code tied to this card order
         */
        couponCode?: string;
        totalAmountEUR?: number | null;
        totalDiscountEUR: number;
        /**
         * When the order was created
         */
        createdAt: string;
    }>;
};

export type GetApiV1OrderResponse = GetApiV1OrderResponses[keyof GetApiV1OrderResponses];

export type GetApiV1SafeConfigData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/safe-config';
};

export type GetApiV1SafeConfigErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Internal server error.
     */
    500: unknown;
};

export type GetApiV1SafeConfigError = GetApiV1SafeConfigErrors[keyof GetApiV1SafeConfigErrors];

export type GetApiV1SafeConfigResponses = {
    /**
     * Successfully retrieved Safe configuration.
     */
    200: SafeConfig;
};

export type GetApiV1SafeConfigResponse = GetApiV1SafeConfigResponses[keyof GetApiV1SafeConfigResponses];

export type PostApiV1SafeSetCurrencyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/safe/set-currency';
};

export type PostApiV1SafeSetCurrencyErrors = {
    /**
     * Bad request (e.g., no Safe account found for user)
     */
    400: {
        /**
         * Error message
         */
        error?: string;
    };
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * User needs to complete KYC successfully
     */
    422: {
        /**
         * Error message
         */
        error?: string;
    };
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type PostApiV1SafeSetCurrencyError = PostApiV1SafeSetCurrencyErrors[keyof PostApiV1SafeSetCurrencyErrors];

export type PostApiV1SafeSetCurrencyResponses = {
    /**
     * Successfully set the currency for the Safe account
     */
    200: {
        /**
         * The token symbol set for the Safe account
         */
        tokenSymbol?: 'EURe' | 'GBPe' | 'USDCe';
    };
};

export type PostApiV1SafeSetCurrencyResponse = PostApiV1SafeSetCurrencyResponses[keyof PostApiV1SafeSetCurrencyResponses];

export type GetApiV1SourceOfFundsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The locale for translating currency values (e.g., 'BR', 'UK')
         */
        locale?: string;
    };
    url: '/api/v1/source-of-funds';
};

export type GetApiV1SourceOfFundsErrors = {
    /**
     * Unauthorized access.
     */
    401: {
        /**
         * Error message.
         */
        error?: string;
    };
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type GetApiV1SourceOfFundsError = GetApiV1SourceOfFundsErrors[keyof GetApiV1SourceOfFundsErrors];

export type GetApiV1SourceOfFundsResponses = {
    /**
     * Successfully retrieved the Source of Funds questions.
     */
    200: Array<KycQuestion>;
};

export type GetApiV1SourceOfFundsResponse = GetApiV1SourceOfFundsResponses[keyof GetApiV1SourceOfFundsResponses];

export type PostApiV1SourceOfFundsData = {
    body: Array<KycAnswer>;
    path?: never;
    query?: never;
    url: '/api/v1/source-of-funds';
};

export type PostApiV1SourceOfFundsErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type PostApiV1SourceOfFundsError = PostApiV1SourceOfFundsErrors[keyof PostApiV1SourceOfFundsErrors];

export type PostApiV1SourceOfFundsResponses = {
    /**
     * Source of Funds answers submitted successfully.
     */
    200: {
        message?: string;
    };
};

export type PostApiV1SourceOfFundsResponse = PostApiV1SourceOfFundsResponses[keyof PostApiV1SourceOfFundsResponses];

export type GetApiV1TransactionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Comma-separated list of card tokens
         */
        cardTokens?: string;
        /**
         * Filter transactions before this date (ISO 8601 format, e.g., "2023-04-01T00:00:00Z")
         */
        before?: string;
        /**
         * Filter transactions after this date (ISO 8601 format, e.g., "2023-03-01T00:00:00Z")
         */
        after?: string;
        /**
         * Filter by billing currency code
         */
        billingCurrency?: string;
        /**
         * Filter by transaction currency code
         */
        transactionCurrency?: string;
        /**
         * Filter by Merchant Category Code (MCC)
         */
        mcc?: string;
        /**
         * Filter by transaction type code (e.g., "00" for Purchase, "01" for Withdrawal)
         */
        transactionType?: string;
    };
    url: '/api/v1/transactions';
};

export type GetApiV1TransactionsErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type GetApiV1TransactionsError = GetApiV1TransactionsErrors[keyof GetApiV1TransactionsErrors];

export type GetApiV1TransactionsResponses = {
    /**
     * Successful response
     */
    200: Array<Event>;
};

export type GetApiV1TransactionsResponse = GetApiV1TransactionsResponses[keyof GetApiV1TransactionsResponses];

export type PostApiV1VerificationCheckData = {
    body: {
        code: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/verification/check';
};

export type PostApiV1VerificationCheckErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Validation error occurred.
     */
    422: {
        error?: 'User has no phone number' | 'Verification failed';
    };
    /**
     * Failed to send verification.
     */
    500: unknown;
};

export type PostApiV1VerificationCheckError = PostApiV1VerificationCheckErrors[keyof PostApiV1VerificationCheckErrors];

export type PostApiV1VerificationCheckResponses = {
    /**
     * Phone was verified successfully
     */
    200: {
        ok?: boolean;
    };
};

export type PostApiV1VerificationCheckResponse = PostApiV1VerificationCheckResponses[keyof PostApiV1VerificationCheckResponses];

export type PostApiV1VerificationData = {
    body: {
        phoneNumber: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/verification';
};

export type PostApiV1VerificationErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * User not found.
     */
    404: {
        error?: string;
    };
    /**
     * Failed validation and OTP was not sent.
     */
    422: {
        error?: 'Invalid phone number' | 'Phone number already validated' | 'User needs to be KYC approved';
    };
    /**
     * Maximum verification attempts reached. Please try again later.
     */
    429: {
        error?: string;
    };
    /**
     * Failed to send verification.
     */
    500: unknown;
};

export type PostApiV1VerificationError = PostApiV1VerificationErrors[keyof PostApiV1VerificationErrors];

export type PostApiV1VerificationResponses = {
    /**
     * OTP was sent.
     */
    200: {
        ok?: boolean;
    };
};

export type PostApiV1VerificationResponse = PostApiV1VerificationResponses[keyof PostApiV1VerificationResponses];

export type GetApiV1AccountsOnchainDailyLimitData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/accounts/onchain-daily-limit';
};

export type GetApiV1AccountsOnchainDailyLimitErrors = {
    /**
     * Unauthorized - invalid or missing authentication token.
     */
    401: {
        /**
         * Authentication error message.
         */
        error?: string;
    };
    /**
     * Safe account or token not found for the user.
     */
    404: {
        /**
         * Error message explaining why the request failed.
         */
        error?: string;
    };
    /**
     * Internal server error.
     */
    500: {
        /**
         * Details about the server error.
         */
        message?: string;
    };
};

export type GetApiV1AccountsOnchainDailyLimitError = GetApiV1AccountsOnchainDailyLimitErrors[keyof GetApiV1AccountsOnchainDailyLimitErrors];

export type GetApiV1AccountsOnchainDailyLimitResponses = {
    /**
     * Successfully retrieved the current onchain daily limit.
     */
    200: {
        data: {
            /**
             * The current daily spending limit in the Safe token's base units.
             */
            onchainDailyLimit: number;
        };
    };
};

export type GetApiV1AccountsOnchainDailyLimitResponse = GetApiV1AccountsOnchainDailyLimitResponses[keyof GetApiV1AccountsOnchainDailyLimitResponses];

export type PutApiV1AccountsOnchainDailyLimitData = {
    body: {
        /**
         * The new daily spending limit to set (must be an integer).
         */
        onchainDailyLimit: number;
        /**
         * The wallet signature authorizing this limit change.
         */
        signature: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/accounts/onchain-daily-limit';
};

export type PutApiV1AccountsOnchainDailyLimitErrors = {
    /**
     * Bad request - invalid signature.
     */
    400: {
        /**
         * Details about the validation error.
         */
        error?: string;
    };
    /**
     * Unauthorized - invalid or missing authentication token.
     */
    401: {
        /**
         * Authentication error message.
         */
        error?: string;
    };
    /**
     * Safe account or token not found for the user.
     */
    404: {
        /**
         * Error message explaining why the request failed.
         */
        error?: string;
    };
    /**
     * Unprocessable Entity - validation errors in request body.
     */
    422: {
        /**
         * Details about the validation error.
         */
        error?: string;
    };
    /**
     * Internal server error.
     */
    500: {
        /**
         * Details about the server error.
         */
        message?: string;
    };
};

export type PutApiV1AccountsOnchainDailyLimitError = PutApiV1AccountsOnchainDailyLimitErrors[keyof PutApiV1AccountsOnchainDailyLimitErrors];

export type PutApiV1AccountsOnchainDailyLimitResponses = {
    /**
     * Successfully submitted the daily limit update request.
     */
    200: {
        data: {
            /**
             * The daily limit value that was requested to be set.
             */
            requestedOnchainDailyLimit: number;
        };
    };
};

export type PutApiV1AccountsOnchainDailyLimitResponse = PutApiV1AccountsOnchainDailyLimitResponses[keyof PutApiV1AccountsOnchainDailyLimitResponses];

export type GetApiV1AccountsOnchainDailyLimitTransactionDataData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The new daily spending limit to set (1-5000, must be an integer).
         */
        onchainDailyLimit: string;
    };
    url: '/api/v1/accounts/onchain-daily-limit/transaction-data';
};

export type GetApiV1AccountsOnchainDailyLimitTransactionDataErrors = {
    /**
     * Unauthorized - invalid or missing authentication token.
     */
    401: {
        /**
         * Authentication error message.
         */
        error?: string;
    };
    /**
     * Safe account or token not found for the user.
     */
    404: {
        /**
         * Error message explaining why the request failed.
         */
        error?: string;
    };
    /**
     * Unprocessable Entity - validation errors in query parameters.
     */
    422: {
        /**
         * Details about the validation error.
         */
        error?: string;
    };
    /**
     * Internal server error.
     */
    500: {
        /**
         * Details about the server error.
         */
        message?: string;
    };
};

export type GetApiV1AccountsOnchainDailyLimitTransactionDataError = GetApiV1AccountsOnchainDailyLimitTransactionDataErrors[keyof GetApiV1AccountsOnchainDailyLimitTransactionDataErrors];

export type GetApiV1AccountsOnchainDailyLimitTransactionDataResponses = {
    /**
     * Successfully retrieved transaction data for signing.
     */
    200: {
        data: {
            transaction: {
                /**
                 * The target contract address for the transaction.
                 */
                to: string;
                /**
                 * The amount of native tokens to send with the transaction (usually 0).
                 */
                value: number;
                /**
                 * The encoded transaction data containing the function call.
                 */
                data: string;
            };
        };
    };
};

export type GetApiV1AccountsOnchainDailyLimitTransactionDataResponse = GetApiV1AccountsOnchainDailyLimitTransactionDataResponses[keyof GetApiV1AccountsOnchainDailyLimitTransactionDataResponses];

export type GetApiV1EoaAccountsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/eoa-accounts';
};

export type GetApiV1EoaAccountsErrors = {
    /**
     * Unauthorized, missing or invalid token.
     */
    401: unknown;
    /**
     * Internal server error.
     */
    500: unknown;
};

export type GetApiV1EoaAccountsResponses = {
    /**
     * A list of EOA accounts for the current user.
     */
    200: {
        data?: {
            eoaAccounts?: Array<EoaAccount>;
        };
    };
};

export type GetApiV1EoaAccountsResponse = GetApiV1EoaAccountsResponses[keyof GetApiV1EoaAccountsResponses];

export type PostApiV1EoaAccountsData = {
    body: {
        /**
         * The Ethereum address of the new externally owned account.
         */
        address?: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/eoa-accounts';
};

export type PostApiV1EoaAccountsErrors = {
    /**
     * Invalid request body or address format.
     */
    400: unknown;
    /**
     * Unauthorized, missing or invalid token.
     */
    401: unknown;
    /**
     * Internal server error.
     */
    500: unknown;
};

export type PostApiV1EoaAccountsResponses = {
    /**
     * Successfully created EOA account.
     */
    201: EoaAccount;
};

export type PostApiV1EoaAccountsResponse = PostApiV1EoaAccountsResponses[keyof PostApiV1EoaAccountsResponses];

export type DeleteApiV1EoaAccountsByIdData = {
    body?: never;
    path: {
        /**
         * The ID of the externally owned account to be deleted.
         */
        id: string;
    };
    query?: never;
    url: '/api/v1/eoa-accounts/{id}';
};

export type DeleteApiV1EoaAccountsByIdErrors = {
    /**
     * Invalid account ID format.
     */
    400: unknown;
    /**
     * Unauthorized, missing or invalid token.
     */
    401: unknown;
    /**
     * Forbidden. Cannot delete the last EOA account a user has.
     */
    403: unknown;
    /**
     * Couldn't find a belonging EOA account.
     */
    404: unknown;
    /**
     * Internal server error.
     */
    500: unknown;
};

export type DeleteApiV1EoaAccountsByIdResponses = {
    /**
     * Successfully deleted the EOA account.
     */
    200: {
        data?: {
            id?: string;
        };
    };
};

export type DeleteApiV1EoaAccountsByIdResponse = DeleteApiV1EoaAccountsByIdResponses[keyof DeleteApiV1EoaAccountsByIdResponses];

export type GetApiV1IbansAvailableData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/ibans/available';
};

export type GetApiV1IbansAvailableErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type GetApiV1IbansAvailableError = GetApiV1IbansAvailableErrors[keyof GetApiV1IbansAvailableErrors];

export type GetApiV1IbansAvailableResponses = {
    /**
     * IBAN availability status for the user.
     */
    200: {
        data: {
            /**
             * Indicates if the user is eligible to enable an IBAN.
             */
            available: boolean;
        };
    };
};

export type GetApiV1IbansAvailableResponse = GetApiV1IbansAvailableResponses[keyof GetApiV1IbansAvailableResponses];

export type GetApiV1IbansDetailsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/ibans/details';
};

export type GetApiV1IbansDetailsErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type GetApiV1IbansDetailsError = GetApiV1IbansDetailsErrors[keyof GetApiV1IbansDetailsErrors];

export type GetApiV1IbansDetailsResponses = {
    /**
     * Successfully retrieved IBAN details
     */
    200: {
        data?: {
            iban?: string | null;
            bic?: string | null;
            ibanStatus: 'NOTSTARTED' | 'PENDING' | 'PENDING_OAUTH' | 'ASSIGNED';
            /**
             * The blockchain address associated with this IBAN account
             */
            address?: string | null;
        };
    };
};

export type GetApiV1IbansDetailsResponse = GetApiV1IbansDetailsResponses[keyof GetApiV1IbansDetailsResponses];

export type PostApiV1IbansMoneriumProfileData = {
    body?: {
        /**
         * Signature of the message "I hereby declare that I am the address owner."
         * This signature is created by signing the message with the user's wallet.
         * The exact message can be retrieved from the /api/v1/ibans/signing-message endpoint.
         * The signature is used to verify ownership of the address on Monerium.
         * Format: Ethereum signature string (e.g., "0x1234...").
         *
         */
        signature?: string;
        /**
         * Optional URL to redirect the user to after the OAuth flow is completed.
         * This is used when the user already has a Monerium account that needs to be linked.
         * If not provided, a default redirect URL will be used.
         *
         */
        callbackUrl?: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/ibans/monerium-profile';
};

export type PostApiV1IbansMoneriumProfileErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * User already has a Monerium profile that needs to be linked
     */
    422: {
        errors?: {
            redirectUrl: string;
            message: string;
        };
    };
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type PostApiV1IbansMoneriumProfileError = PostApiV1IbansMoneriumProfileErrors[keyof PostApiV1IbansMoneriumProfileErrors];

export type PostApiV1IbansMoneriumProfileResponses = {
    /**
     * Successfully created a new Monerium profile
     */
    200: {
        data?: {
            success: boolean;
        };
    };
};

export type PostApiV1IbansMoneriumProfileResponse = PostApiV1IbansMoneriumProfileResponses[keyof PostApiV1IbansMoneriumProfileResponses];

export type GetApiV1IbansOauthRedirectUrlData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional URL to redirect the user to after the OAuth flow is completed. If not provided, a default redirect URL will be used.
         */
        callbackUrl?: string;
    };
    url: '/api/v1/ibans/oauth/redirect_url';
};

export type GetApiV1IbansOauthRedirectUrlErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type GetApiV1IbansOauthRedirectUrlError = GetApiV1IbansOauthRedirectUrlErrors[keyof GetApiV1IbansOauthRedirectUrlErrors];

export type GetApiV1IbansOauthRedirectUrlResponses = {
    /**
     * Successfully retrieved the redirect URL
     */
    200: {
        data?: {
            redirectUrl: string;
        };
    };
};

export type GetApiV1IbansOauthRedirectUrlResponse = GetApiV1IbansOauthRedirectUrlResponses[keyof GetApiV1IbansOauthRedirectUrlResponses];

export type DeleteApiV1IbansResetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/ibans/reset';
};

export type DeleteApiV1IbansResetErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type DeleteApiV1IbansResetError = DeleteApiV1IbansResetErrors[keyof DeleteApiV1IbansResetErrors];

export type DeleteApiV1IbansResetResponses = {
    /**
     * Successfully created or linked Monerium profile
     */
    200: {
        data?: {
            success: boolean;
        };
    };
};

export type DeleteApiV1IbansResetResponse = DeleteApiV1IbansResetResponses[keyof DeleteApiV1IbansResetResponses];

export type GetApiV1IbansOrdersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/ibans/orders';
};

export type GetApiV1IbansOrdersErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type GetApiV1IbansOrdersError = GetApiV1IbansOrdersErrors[keyof GetApiV1IbansOrdersErrors];

export type GetApiV1IbansOrdersResponses = {
    /**
     * A list of Monerium IBAN orders
     */
    200: {
        data?: Array<IbanOrder>;
    };
};

export type GetApiV1IbansOrdersResponse = GetApiV1IbansOrdersResponses[keyof GetApiV1IbansOrdersResponses];

export type GetApiV1IbansSigningMessageData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/ibans/signing-message';
};

export type GetApiV1IbansSigningMessageErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type GetApiV1IbansSigningMessageError = GetApiV1IbansSigningMessageErrors[keyof GetApiV1IbansSigningMessageErrors];

export type GetApiV1IbansSigningMessageResponses = {
    /**
     * Successfully retrieved the signing message
     */
    200: {
        data?: {
            message?: string;
        };
    };
};

export type GetApiV1IbansSigningMessageResponse = GetApiV1IbansSigningMessageResponses[keyof GetApiV1IbansSigningMessageResponses];

export type GetApiV1KycIntegrationData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional language code in ISO 639-1 format (2 letters) to force the KYC flow language. If not provided, SumSub will use its own rules to determine the language.
         */
        lang?: string;
    };
    url: '/api/v1/kyc/integration';
};

export type GetApiV1KycIntegrationErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * The user has already been approved
     */
    409: {
        /**
         * Details about the error.
         */
        message?: string;
    };
    /**
     * Internal server error.
     */
    500: {
        /**
         * Details about the server error.
         */
        message?: string;
    };
};

export type GetApiV1KycIntegrationError = GetApiV1KycIntegrationErrors[keyof GetApiV1KycIntegrationErrors];

export type GetApiV1KycIntegrationResponses = {
    /**
     * The KYC integration specification.
     */
    200: {
        /**
         * The type of the KYC integration.
         */
        type: 'SUMSUB_WEB';
        /**
         * The url that needs to be opened to follow through the SumSub KYC flow.
         */
        url: string;
    };
};

export type GetApiV1KycIntegrationResponse = GetApiV1KycIntegrationResponses[keyof GetApiV1KycIntegrationResponses];

export type GetApiV1KycIntegrationSdkData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional language code in ISO 639-1 format (2 letters) to force the KYC flow language. If not provided, SumSub will use its own rules to determine the language.
         */
        lang?: string;
    };
    url: '/api/v1/kyc/integration/sdk';
};

export type GetApiV1KycIntegrationSdkErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * The user has already been approved
     */
    409: {
        /**
         * Details about the error.
         */
        message?: string;
    };
    /**
     * Internal server error.
     */
    500: {
        /**
         * Details about the server error.
         */
        message?: string;
    };
};

export type GetApiV1KycIntegrationSdkError = GetApiV1KycIntegrationSdkErrors[keyof GetApiV1KycIntegrationSdkErrors];

export type GetApiV1KycIntegrationSdkResponses = {
    /**
     * The KYC integration specification.
     */
    200: {
        /**
         * The type of the KYC integration.
         */
        type: 'SUMSUB_SDK';
        /**
         * The token that needs to be used to follow through the SumSub KYC flow.
         */
        token: string;
        /**
         * The user ID.
         */
        userId: string;
    };
};

export type GetApiV1KycIntegrationSdkResponse = GetApiV1KycIntegrationSdkResponses[keyof GetApiV1KycIntegrationSdkResponses];

export type PostApiV1KycImportPartnerApplicantData = {
    body: {
        forClientId?: string;
        ttlInSecs?: number;
    };
    path?: never;
    query?: never;
    url: '/api/v1/kyc/import-partner-applicant';
};

export type PostApiV1KycImportPartnerApplicantErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type PostApiV1KycImportPartnerApplicantError = PostApiV1KycImportPartnerApplicantErrors[keyof PostApiV1KycImportPartnerApplicantErrors];

export type PostApiV1KycImportPartnerApplicantResponses = {
    /**
     * Successfully retrieved Sumsub's reusable token.
     */
    200: {
        token?: string;
        forClientId?: string;
    };
};

export type PostApiV1KycImportPartnerApplicantResponse = PostApiV1KycImportPartnerApplicantResponses[keyof PostApiV1KycImportPartnerApplicantResponses];

export type PostApiV1OrderByOrderIdCardData = {
    body: {
        encryptedKey: string;
        encryptedPin: string;
        iv: string;
        options: {
            /**
             * Discriminator property, must be true for this schema.
             */
            setPin: boolean;
        };
    } | {
        options: {
            /**
             * Discriminator property, must be false for this schema.
             */
            setPin: boolean;
        };
    };
    path: {
        /**
         * The unique identifier of the card order.
         */
        orderId: string;
    };
    query?: never;
    url: '/api/v1/order/{orderId}/card';
};

export type PostApiV1OrderByOrderIdCardErrors = {
    /**
     * Not authorised
     */
    401: unknown;
    /**
     * The card order was not found
     */
    404: unknown;
    /**
     * Criteria not met
     */
    422: unknown;
    /**
     * Unexpected error
     */
    500: unknown;
};

export type PostApiV1OrderByOrderIdCardResponses = {
    /**
     * The card was created
     */
    200: {
        success?: boolean;
    };
};

export type PostApiV1OrderByOrderIdCardResponse = PostApiV1OrderByOrderIdCardResponses[keyof PostApiV1OrderByOrderIdCardResponses];

export type PutApiV1OrderByOrderIdAttachTransactionData = {
    body: {
        /**
         * The on-chain transaction hash to be attached.
         */
        transactionHash: string;
    };
    path: {
        /**
         * The unique identifier of the card order to which the transaction will be attached.
         */
        orderId: string;
    };
    query?: never;
    url: '/api/v1/order/{orderId}/attach-transaction';
};

export type PutApiV1OrderByOrderIdAttachTransactionErrors = {
    /**
     * Invalid transaction or hash already used.
     */
    400: {
        /**
         * Details about the error.
         */
        message?: string;
    };
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Card order not found.
     */
    404: {
        /**
         * Details about the error.
         */
        message?: string;
    };
    /**
     * Internal server error.
     */
    500: {
        /**
         * Details about the server error.
         */
        message?: string;
    };
};

export type PutApiV1OrderByOrderIdAttachTransactionError = PutApiV1OrderByOrderIdAttachTransactionErrors[keyof PutApiV1OrderByOrderIdAttachTransactionErrors];

export type PutApiV1OrderByOrderIdAttachTransactionResponses = {
    /**
     * Transaction successfully attached to the card order.
     */
    200: {
        /**
         * Indicates if the operation was successful.
         */
        ok?: boolean;
    };
};

export type PutApiV1OrderByOrderIdAttachTransactionResponse = PutApiV1OrderByOrderIdAttachTransactionResponses[keyof PutApiV1OrderByOrderIdAttachTransactionResponses];

export type PostApiV1OrderByOrderIdAttachCouponData = {
    body: {
        /**
         * The coupon code to be applied to the order.
         */
        couponCode: string;
    };
    path: {
        /**
         * The unique identifier of the card order to which the coupon will be attached.
         */
        orderId: string;
    };
    query?: never;
    url: '/api/v1/order/{orderId}/attach-coupon';
};

export type PostApiV1OrderByOrderIdAttachCouponErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Card order not found.
     */
    404: {
        /**
         * Details about the error.
         */
        message?: string;
    };
    /**
     * Coupon code is invalid.
     */
    422: {
        /**
         * Details about the error.
         */
        message?: string;
    };
    /**
     * Internal server error.
     */
    500: {
        /**
         * Details about the server error.
         */
        message?: string;
    };
};

export type PostApiV1OrderByOrderIdAttachCouponError = PostApiV1OrderByOrderIdAttachCouponErrors[keyof PostApiV1OrderByOrderIdAttachCouponErrors];

export type PostApiV1OrderByOrderIdAttachCouponResponses = {
    /**
     * Coupon successfully attached to the card order.
     */
    200: {
        /**
         * The coupon code that was applied to the order.
         */
        couponCode?: string;
    };
};

export type PostApiV1OrderByOrderIdAttachCouponResponse = PostApiV1OrderByOrderIdAttachCouponResponses[keyof PostApiV1OrderByOrderIdAttachCouponResponses];

export type GetApiV1OrderByOrderIdData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the card order.
         */
        orderId: string;
    };
    query?: never;
    url: '/api/v1/order/{orderId}';
};

export type GetApiV1OrderByOrderIdErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Card order not found.
     */
    404: {
        /**
         * Details about the error.
         */
        message?: string;
    };
    /**
     * Internal server error.
     */
    500: {
        /**
         * Details about the server error.
         */
        message?: string;
    };
};

export type GetApiV1OrderByOrderIdError = GetApiV1OrderByOrderIdErrors[keyof GetApiV1OrderByOrderIdErrors];

export type GetApiV1OrderByOrderIdResponses = {
    /**
     * Successfully retrieved card order details.
     */
    200: {
        /**
         * The unique identifier of the card order.
         */
        id: string;
        /**
         * The on-chain transaction hash associated with the order.
         */
        transactionHash?: string | null;
        /**
         * The name embossed on the card.
         */
        embossedName?: string | null;
        /**
         * The first line of the shipping address.
         */
        address1?: string | null;
        /**
         * The second line of the shipping address.
         */
        address2?: string | null;
        /**
         * The city of the shipping address.
         */
        city?: string | null;
        /**
         * The postal code of the shipping address.
         */
        postalCode?: string | null;
        /**
         * The state of the shipping address.
         */
        state?: string | null;
        /**
         * The country of the shipping address.
         */
        country?: string | null;
        /**
         * The user id for this card order.
         */
        userId: string;
        /**
         * Current order status
         */
        status: 'PENDINGTRANSACTION' | 'TRANSACTIONCOMPLETE' | 'CONFIRMATIONREQUIRED' | 'READY' | 'CARDCREATED' | 'FAILEDTRANSACTION' | 'CANCELLED';
        personalizationSource: 'KYC' | 'ENS';
        /**
         * The coupon code tied to this card order
         */
        couponCode?: string;
        totalAmountEUR?: number | null;
        totalDiscountEur?: number;
        /**
         * When the order was created
         */
        createdAt: string;
    };
};

export type GetApiV1OrderByOrderIdResponse = GetApiV1OrderByOrderIdResponses[keyof GetApiV1OrderByOrderIdResponses];

export type PutApiV1OrderByOrderIdConfirmPaymentData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the card order.
         */
        orderId: string;
    };
    query?: never;
    url: '/api/v1/order/{orderId}/confirm-payment';
};

export type PutApiV1OrderByOrderIdConfirmPaymentErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Card Order is not in the correct status.
         */
        message?: string;
    } | {
        /**
         * No transaction hash found for this order.
         */
        message?: string;
    } | {
        /**
         * Could not find payment in transaction hash.
         */
        message?: string;
    };
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Card order not found.
     */
    404: {
        /**
         * Details about the error.
         */
        message?: string;
    };
    /**
     * Internal server error.
     */
    500: {
        /**
         * Details about the server error.
         */
        message?: string;
    };
};

export type PutApiV1OrderByOrderIdConfirmPaymentError = PutApiV1OrderByOrderIdConfirmPaymentErrors[keyof PutApiV1OrderByOrderIdConfirmPaymentErrors];

export type PutApiV1OrderByOrderIdConfirmPaymentResponses = {
    /**
     * Transaction successfully attached to the card order.
     */
    200: {
        /**
         * Indicates if the operation was successful.
         */
        ok?: boolean;
    };
};

export type PutApiV1OrderByOrderIdConfirmPaymentResponse = PutApiV1OrderByOrderIdConfirmPaymentResponses[keyof PutApiV1OrderByOrderIdConfirmPaymentResponses];

export type PostApiV1OrderByOrderIdCancelData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the card order to cancel.
         */
        orderId: string;
    };
    query?: never;
    url: '/api/v1/order/{orderId}/cancel';
};

export type PostApiV1OrderByOrderIdCancelErrors = {
    /**
     * Invalid order transition or order not in cancellable state.
     */
    400: {
        message?: string;
    };
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Card order not found.
     */
    404: {
        message?: string;
    };
    /**
     * Internal server error.
     */
    500: {
        message?: string;
    };
};

export type PostApiV1OrderByOrderIdCancelError = PostApiV1OrderByOrderIdCancelErrors[keyof PostApiV1OrderByOrderIdCancelErrors];

export type PostApiV1OrderByOrderIdCancelResponses = {
    /**
     * Card order successfully cancelled.
     */
    200: {
        ok?: boolean;
    };
};

export type PostApiV1OrderByOrderIdCancelResponse = PostApiV1OrderByOrderIdCancelResponses[keyof PostApiV1OrderByOrderIdCancelResponses];

export type PostApiV1OrderCreateData = {
    body: {
        personalizationSource: 'ENS';
        ENSName: string;
        shippingAddress?: {
            address1: string;
            address2?: string | null;
            city: string;
            postalCode: string;
            country: string;
        } | null;
        virtual?: boolean;
    } | {
        personalizationSource: 'KYC';
        shippingAddress?: {
            address1: string;
            address2?: string | null;
            city: string;
            postalCode: string;
            country: string;
        } | null;
        virtual?: boolean;
    };
    path?: never;
    query?: never;
    url: '/api/v1/order/create';
};

export type PostApiV1OrderCreateErrors = {
    /**
     * Bad Request - One of several possible client errors
     */
    400: 'Error: There is already a pending card order' | 'Error: User is not approved through KYC' | 'Error: Unknown personalization source' | "Error: Shipping needs to be done to the user's country";
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type PostApiV1OrderCreateError = PostApiV1OrderCreateErrors[keyof PostApiV1OrderCreateErrors];

export type PostApiV1OrderCreateResponses = {
    /**
     * Card order created successfully
     */
    200: CardOrder;
};

export type PostApiV1OrderCreateResponse = PostApiV1OrderCreateResponses[keyof PostApiV1OrderCreateResponses];

export type GetApiV1RewardsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/rewards';
};

export type GetApiV1RewardsErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Internal server error
     */
    500: {
        error?: string;
    };
};

export type GetApiV1RewardsError = GetApiV1RewardsErrors[keyof GetApiV1RewardsErrors];

export type GetApiV1RewardsResponses = {
    /**
     * Successfully retrieved rewards information
     */
    200: {
        /**
         * Indicates if the user holds an OG NFT token. If true, the user gets an additional 1% cashback on top of the base cashbackRate.
         */
        isOg: boolean;
        /**
         * User's GNO token balance in their Safe account
         */
        gnoBalance: number;
        /**
         * Base cashback rate calculated from GNO balance (0-4%). For OG NFT holders, add 1% to this rate to get the total cashback rate.
         */
        cashbackRate: number;
    };
};

export type GetApiV1RewardsResponse = GetApiV1RewardsResponses[keyof GetApiV1RewardsResponses];

export type PostApiV1UserReferrerCodeData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/user/referrer-code';
};

export type PostApiV1UserReferrerCodeErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Request validation error
     */
    422: {
        message?: string;
    };
    /**
     * Server error
     */
    500: {
        error?: string;
    };
};

export type PostApiV1UserReferrerCodeError = PostApiV1UserReferrerCodeErrors[keyof PostApiV1UserReferrerCodeErrors];

export type PostApiV1UserReferrerCodeResponses = {
    /**
     * Successfully retrieved or created referral code
     */
    200: {
        /**
         * ID of the authenticated user
         */
        userId: string;
        /**
         * User's referral code for sharing
         */
        referrerCode: string;
    };
};

export type PostApiV1UserReferrerCodeResponse = PostApiV1UserReferrerCodeResponses[keyof PostApiV1UserReferrerCodeResponses];

export type GetApiV1UserReferralsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/user/referrals';
};

export type GetApiV1UserReferralsErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Server error
     */
    500: {
        error?: string;
    };
};

export type GetApiV1UserReferralsError = GetApiV1UserReferralsErrors[keyof GetApiV1UserReferralsErrors];

export type GetApiV1UserReferralsResponses = {
    /**
     * Successfully retrieved referral status
     */
    200: {
        /**
         * Indicates if the user is an OG token holder
         */
        isOgTokenHolder?: boolean | null;
        /**
         * Number of pending referrals
         */
        pendingReferrals: number;
        /**
         * Number of completed referrals
         */
        completedReferrals: number;
    };
};

export type GetApiV1UserReferralsResponse = GetApiV1UserReferralsResponses[keyof GetApiV1UserReferralsResponses];

export type GetApiV1UserTermsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/user/terms';
};

export type GetApiV1UserTermsErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Request validation error
     */
    422: {
        message?: string;
    };
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type GetApiV1UserTermsError = GetApiV1UserTermsErrors[keyof GetApiV1UserTermsErrors];

export type GetApiV1UserTermsResponses = {
    /**
     * Successfully retrieved terms status
     */
    200: {
        terms?: Array<{
            /**
             * Type of terms and conditions
             */
            type?: 'general-tos' | 'card-monavate-tos' | 'cashback-tos';
            /**
             * Current version of these terms
             */
            currentVersion?: string;
            /**
             * Whether the user has accepted the current version
             */
            accepted?: boolean;
            /**
             * Version the user has accepted (if any)
             */
            acceptedVersion?: string | null;
            /**
             * When the user accepted these terms
             */
            acceptedAt?: string | null;
            /**
             * URL to view these terms
             */
            url?: string;
        }>;
    };
};

export type GetApiV1UserTermsResponse = GetApiV1UserTermsResponses[keyof GetApiV1UserTermsResponses];

export type PostApiV1UserTermsData = {
    body: {
        /**
         * Type of terms and conditions
         */
        terms: 'general-tos' | 'card-monavate-tos' | 'cashback-tos';
        /**
         * Version of the terms document
         */
        version: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/user/terms';
};

export type PostApiV1UserTermsErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Validation error
     */
    422: {
        message?: string;
    };
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type PostApiV1UserTermsError = PostApiV1UserTermsErrors[keyof PostApiV1UserTermsErrors];

export type PostApiV1UserTermsResponses = {
    /**
     * Terms accepted successfully
     */
    200: {
        ok?: boolean;
    };
};

export type PostApiV1UserTermsResponse = PostApiV1UserTermsResponses[keyof PostApiV1UserTermsResponses];

export type GetApiV1UserData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/user';
};

export type GetApiV1UserErrors = {
    /**
     * Unauthorized Error
     */
    401: {
        message?: string;
    };
    /**
     * Request validation error
     */
    422: {
        message?: string;
    };
    /**
     * Internal Server Error
     */
    500: _Error;
};

export type GetApiV1UserError = GetApiV1UserErrors[keyof GetApiV1UserErrors];

export type GetApiV1UserResponses = {
    /**
     * Successfully retrieved User profile
     */
    200: User;
};

export type GetApiV1UserResponse = GetApiV1UserResponses[keyof GetApiV1UserResponses];

export type ClientOptions = {
    baseUrl: `${string}://${string}` | (string & {});
};